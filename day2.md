## day2
### 枚举
是一种特殊类型，用来做信息的标志和信息的分类  
```java
public enum Season{
  //枚举的第一行必须罗列对象名称
  SPRING,SUMMER,AUTUMN,WINTER;
 }
 public static void move(Season s){
  switch(s){
    case:SPRING:
    case:SUMMER:
    case:AUTUMN:
    case:WINTER:
    }
  }
 ```
 枚举类都是继承了枚举类型：java.lang.Enum  
 枚举都是最终类，不能被继承  
 构造器的构造器都是私有的，枚举不能对外创建对象  
 枚举类的第一行默认都是罗列枚举对象的名称的   
 枚举类相当于是多例模式  
 ### 抽象类  
 修饰符 abstract class 类名{}  
 #### 抽象方法  
 修饰符 abstract 类型 方法名()  
 
 可以被子类继承，充当模板，同时也可以提高代码复用  
 如果父类知道子类要完成某个功能，实现要交给子类时  
 抽象方法只有方法签名，没有方法体，使用abstract修饰  
 如果要继承抽象类，那么这个类必须重写完抽象类的全部抽象方法，否则这个类也必须定义为抽象类  
 
 ### 抽象类注意事项
 有得有失，得到了抽象方法，失去了创建对象的能力  
 抽象类一定有构造器，但是不能创建对象，因为抽象类本身的抽象方法是没有方法体的，是由子类继承后进行具体实现的，抽象本身就意味着不许创建对象，即使抽象类中没有定义抽象方法  
 类有的成员（成员变量，方法，构造器）抽象类都具备  
 抽象类中不一定有抽象方法，但是有抽象方法的类一定是抽象类  
 一个类如果继承了抽象类，必须重写玩抽象类的全部抽象方法，否则这个类必须定义成抽象类  
 abstract不能修饰变量，代码块，构造器，只有抽象类和抽象方法的概念  
 
 ###  final和abstract是什么关系
 互斥关系，因为final修饰的类是不可继承的，而abstract就是想要子类继承从而重写类内的抽象方法  
 抽象方法定义通用功能让子类重写，final定义的方法子类不能重写  
 
 ### 抽象类的应用，模板方法模式
 当系统中出现同一个功能在多出开发，而该功能中大部分代码是一样的，只有其中部分可能不同的时候  
 #### 实现步骤
 把功能定义成一个所谓的模板方法，放在抽象类中，模板方法中只能定义通用且能确定的代码  
 不能决定的功能定义成抽象方法让具体子类去实现 
 模板方法最好是在开头加final修饰，因为它是给子类直接使用的，不是让子类重写的，一旦子类重写模板方法，那这个方法就失效了  
 
 ### 接口
 接口是更加彻底的抽象  在jdk8之前：
 ```java
 public interface 接口名{
    //常量
    //抽象方法
 }
 ```
 接口不能实例化  
 接口中的成员都是public修饰的，写不写都是，因为规范的目的是为了公开化  
 ```java
 public interface SportManInterface{
 	//接口中的成员：JDK1.8之前只有常量 和 抽象方法
	//public static final 可以省略不写，接口会默认为你加上
 	String SCHOOL_NAME="NEW YORK UNIVERSITY"//等同于public static final String SCHOOL_NAME="NEW YORK UNIVERSITY"
	//抽象方法
	public abstract void run()//public abstract 可以省略不写，系统会给你默认加上
	//void run() 即可  
```
### 接口的用法
接口是用来被类实现(implements)的，实现接口的类称为实现类。实现类可以理解成为所谓的子类  
```java
修饰符 class 实现类implements 接口1，接口2，接口3，...{
}
实现的关键字：implements
```
接口可以被类单实现，也可被类多实现  
idea IDE 小技巧，alt+enter可选定需要重新给多少  

#### 接口注意事项
一个类实现接口，需要重写所有接口的全部抽象方法，否则这个类需要定义成抽象类  

#### 总结 
类和类之间关系：单继承  
类和接口的关系：多实现  
接口和接口的关系：多继承（但应该注意如果两个接口有同名函数，行为和返回值都一样，就可以通过多继承，实现类只需要实现一次同名函数，但是返回值或者行为不一样，那通过多继承来简化代码，想要实现类中只实现一次同名函数，就会有冲突）  

### jdk8之后接口新增的特性
允许接口中直接定义带有方法体的方法  
#### 默认方法
类似之前的普通实例方法，必须用default修饰  
默认会被public修饰，需要接口的实现类的对象来调用  
```java
default void run(){
	System.out.println("run");
}
```
#### 静态方法
默认会被public修饰，必须static修饰  
tips：接口的静态方法必须用本身的接口名来调用  
```java
static void inAddr(){
	System.out.println("In new york");
}
```
#### 私有方法
私有的实例方法，必须用private修饰，从JDK9才开始有的  
只能在本类中被其他的默认方法或者私有方法访问  
```java
private void go(){
	System.out.println("run");
}
```
用得少，需要理解，识别，明白调用关系即可  

### 接口的注意事项
接口不能创建对象  
一个类实现多个接口，多个接口中有静态方法不冲突（因为接口的静态方法只能本身接口名来调用A调A的，B调B的）  
一个类继承了父类，同时又实现了接口，父类和接口中有同名方法，默认用父类的，因为继承写在前面，例如：class Cat extends Animal implements Food{}, 若Animal和Food中都有eat方法，那么首先肯定调用Animal类中的eat方法。可以理解为就近原则。而且语法上来说，class Cat implements Fodd extends Animal{}是错误的  
一个类实现了多个接口，多个接口中存在同名的默认方法，不冲突，这个类重写该方法即可  
一个接口继承多个接口，是没有问题的，如果多个接口中存在规范冲突则不能多继承  

